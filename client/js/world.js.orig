function World(scene, container) {
	var self = this;

	self.addToScene = function (mesh) {
		scene.add(mesh);
	};

	self.removeFromScene = function (mesh) {
		scene.remove(mesh);
	};

	var playerName = localStorage.playerName;
	while (!playerName) {
		playerName = prompt("Please enter your name.","Unknown");
		localStorage.playerName = playerName;
	}
	var conn = new Conn(getWSURI("main/" + playerName));
	var controls = new Controls(container);
	var player = new Player(playerName, self, conn, controls);
	var chat = new Chat(controls, conn, container);

	var chunkManager = new ChunkManager(scene, player);
	var entityManager = new EntityManager(scene, conn, player);
	window.testExposure.chunkManager = chunkManager;
	window.testExposure.entityManager = entityManager;

	var ambientLight = new THREE.AmbientLight(0xffffff);
	scene.add(ambientLight);

	conn.on('debug-ray', processRay);

	function processRay(payload) {
		var pos = new THREE.Vector3(payload.Pos.X, payload.Pos.Y, payload.Pos.Z);
		self.addSmallCube(pos);
	}

	self.update = function (dt) {
		player.update(dt);
		chunkManager.update(dt);
		chat.update(dt);
	};

	self.render = player.render;
	self.resize = player.resize;

	var smallCube = new THREE.CubeGeometry(0.1, 0.1, 0.1);
	var smallCubeMat = new THREE.MeshNormalMaterial();
	self.addSmallCube = function (position) {
		if (!position) throw "Position required!";
		var cube = new THREE.Mesh( smallCube, smallCubeMat );
		cube.position = position;
		scene.add(cube);
	};

	self.blockAt = function (wx, wy, wz) {
		var cords = worldToChunk(wx, wy, wz);
		var oc = cords.o;
		var cc = cords.c;

		var chunk = chunkManager.chunk(cc);
		if (!chunk) return null;
		var block = chunk.block(oc);
		if (!block) throw "Could not load blockkk!!!";
		else return block;
	};

	self.findClosestGround = function (wx, wy, wz) {
		var cords = worldToChunk(wx, wy, wz);
		var cc = cords.c;
		var oc = cords.o;

		var chunk = chunkManager.chunk(cc);
		if (!chunk) {
			return false;
		}
		var block = chunk.block(oc);
		if (block.empty()) {
			// Try and find ground below
			while (true) {
				oc.y--;
				if (oc.y < 0) {
					oc.y = CHUNK_HEIGHT - 1;
					cc.y--;
					chunk = chunkManager.chunk(cc);
					if (!chunk) {
						return oc.y + cc.y * CHUNK_HEIGHT + 1;
					}
				}
				block = chunk.block(oc);
				if (block && !block.empty()) {
					return oc.y + cc.y * CHUNK_HEIGHT + 1;
				}
			}
		} else if (!block.empty()) {
			// Try and find air above
			while (true) {
				oc.y++;
				if (oc.y >= CHUNK_HEIGHT) {
					oc.y = 0;
					cc.y++;
					chunk = chunkManager.chunk(cc);
					if (!chunk) {
						return oc.y + cc.y * CHUNK_HEIGHT;
					}
				}
				block = chunk.block(oc);
				if (block && block.empty()) {
					return oc.y + cc.y * CHUNK_HEIGHT;
				}
			}
		} else {
			throw "findClosestGround only knows how to deal with solid and empty. Got " + block.getType();
		}
	};

	var projector = new THREE.Projector();
<<<<<<< HEAD
	function findIntersection(point, look, criteriaFnc, precision, maxDist) {
		var precision = precision || 0.01;
		var maxDist = maxDist || 100;
=======
	function findIntersection(camera, cb, precision, maxDist) {
		precision = precision || 0.01;
		maxDist = maxDist || 100;
		var look = new THREE.Vector3(0, 0, 1);
		// http://myweb.lmu.edu/dondi/share/cg/unproject-explained.pdf
		projector.unprojectVector(look, camera);
>>>>>>> master

		point = point.clone();

		look = look.clone();
		look.setLength(precision);

		for (var dist = 0; dist < maxDist; dist += precision) {
			point.add(look);
			var collision = criteriaFnc(point.x, point.y, point.z);
			if (collision) {
				return {
					point: point,
					dist: dist,
					item: collision,
				};
			}
		}
	}

	self.findPlayerIntersection = function (camera, precision) {
		function entityAt(wx, wy, wz) {
			return entityManager.entityAt(wx, wy, wz);
		}
<<<<<<< HEAD
		return findIntersection(camera.position, getLookedAtDirection(camera), entityAt, precision);
	}
=======
		return findIntersection(camera, entityAt, 0.1);
	};
>>>>>>> master

	function findSolidBlockIntersection(camera, precision) {
		function blockAt(wx, wy, wz) {
			var block = self.blockAt(wx, wy, wz);
			return block && !block.empty();
		}
<<<<<<< HEAD
		return findIntersection(camera.position, getLookedAtDirection(camera), blockAt, precision);
	}

	function getLookedAtDirection(camera) {
		var look = new THREE.Vector3(0, 0, 1);
		// http://myweb.lmu.edu/dondi/share/cg/unproject-explained.pdf
		projector.unprojectVector(look, camera);
		return look.sub(camera.position);
	}

	//wantSolidBlock is true or false, and describes whether a solid block is requested,
	//  or the block right before the solid block (so for example and air block right before the solid block).
	//return a THREE.Vector3 which is the position of the block.
	self.getLookedAtBlock = function(camera, wantSolidBlock) {
		//Very important, without specifying this we cannot accurately backup to find
		//a block before a solid block!
		var precision = 0.1;

		var intersect = findSolidBlockIntersection(camera, precision);
=======
		return findIntersection(camera, blockAt);
	};

	function doLookedAtBlockAction(camera, cmp, action) {
		var intersect = self.findBlockIntersection(camera);
>>>>>>> master
		if (!intersect) {
			console.log("You aren't looking at anything!");
			return;
		}
		var p = intersect.point;

		if(!wantSolidBlock) {
			//We backup to the last point, so should be the block directly before a solid.
			var cameraDirection = getLookedAtDirection(camera).setLength(precision);
			p.sub(cameraDirection);
		}

<<<<<<< HEAD
		return p;
	}
=======
		var x = p.x;
		var y = p.y;
		var z = p.z;

		if (onFace(x)) {
			if (cmp(x + 0.5, y, z)) {
				action(x + 0.5, y, z);
			} else {
				action(x - 0.5, y, z);
			}
		} else if (onFace(y)) {
			if (cmp(x, y + 0.5, z)) {
				action(x, y + 0.5, z);
			} else {
				action(x, y - 0.5, z);
			}
		} else if (onFace(z)) {
			if (cmp(x, y, z + 0.5)) {
				action(x, y, z + 0.5);
			} else {
				action(x, y, z - 0.5);
			}
		} else {
			console.log("Could not find looked at block!");
		}
	}

	self.removeLookedAtBlock = function (camera) {
		function mineable(x, y, z) {
			var block = self.blockAt(x, y, z);
			if (block) return block.mineable();
			else return false;
		}
		function removeBlock(wx, wy, wz) {
			changeBlock(wx, wy, wz, Block.AIR);
		}
		doLookedAtBlockAction(camera, mineable, removeBlock);
	};

	self.addLookedAtBlock = function (camera, blockType) {
		function empty(x, y, z) {
			var block = self.blockAt(x, y, z);
			if (block) return block.empty();
			else return false;
		}
		function addBlock(wx, wy, wz) {
			changeBlock(wx, wy, wz, blockType);
		}
		doLookedAtBlockAction(camera, empty, addBlock);
	};
>>>>>>> master

	self.changeBlock = function(wx, wy, wz, newType) {
		conn.queue('block', {
			Pos: {
				X: Math.floor(wx),
				Y: Math.floor(wy),
				Z: Math.floor(wz),
			},
			Type: newType,
		});
		chunkManager.queueBlockChange(wx, wy, wz, newType);
	}
}

